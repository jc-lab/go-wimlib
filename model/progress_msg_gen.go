package model

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *ProgressDoneWithFile) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path_to_file":
			z.PathToFile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathToFile")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressDoneWithFile) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "path_to_file"
	err = en.Append(0x81, 0xac, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x5f, 0x66, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathToFile)
	if err != nil {
		err = msgp.WrapError(err, "PathToFile")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressDoneWithFile) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "path_to_file"
	o = append(o, 0x81, 0xac, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x5f, 0x66, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.PathToFile)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressDoneWithFile) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path_to_file":
			z.PathToFile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathToFile")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressDoneWithFile) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.PathToFile)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressExtract) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "image":
			z.Image, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Image")
				return
			}
		case "extract_flags":
			z.ExtractFlags, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "ExtractFlags")
				return
			}
		case "wimfile_name":
			z.WimfileName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WimfileName")
				return
			}
		case "image_name":
			z.ImageName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImageName")
				return
			}
		case "target":
			z.Target, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Target")
				return
			}
		case "total_bytes":
			z.TotalBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "total_streams":
			z.TotalStreams, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalStreams")
				return
			}
		case "completed_streams":
			z.CompletedStreams, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedStreams")
				return
			}
		case "part_number":
			z.PartNumber, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "PartNumber")
				return
			}
		case "total_parts":
			z.TotalParts, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "TotalParts")
				return
			}
		case "guid":
			z.Guid, err = dc.ReadBytes(z.Guid)
			if err != nil {
				err = msgp.WrapError(err, "Guid")
				return
			}
		case "current_file_count":
			z.CurrentFileCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CurrentFileCount")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressExtract) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 13
	// write "image"
	err = en.Append(0x8d, 0xa5, 0x69, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Image)
	if err != nil {
		err = msgp.WrapError(err, "Image")
		return
	}
	// write "extract_flags"
	err = en.Append(0xad, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.ExtractFlags)
	if err != nil {
		err = msgp.WrapError(err, "ExtractFlags")
		return
	}
	// write "wimfile_name"
	err = en.Append(0xac, 0x77, 0x69, 0x6d, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.WimfileName)
	if err != nil {
		err = msgp.WrapError(err, "WimfileName")
		return
	}
	// write "image_name"
	err = en.Append(0xaa, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImageName)
	if err != nil {
		err = msgp.WrapError(err, "ImageName")
		return
	}
	// write "target"
	err = en.Append(0xa6, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Target)
	if err != nil {
		err = msgp.WrapError(err, "Target")
		return
	}
	// write "total_bytes"
	err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalBytes)
	if err != nil {
		err = msgp.WrapError(err, "TotalBytes")
		return
	}
	// write "completed_bytes"
	err = en.Append(0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedBytes)
	if err != nil {
		err = msgp.WrapError(err, "CompletedBytes")
		return
	}
	// write "total_streams"
	err = en.Append(0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalStreams)
	if err != nil {
		err = msgp.WrapError(err, "TotalStreams")
		return
	}
	// write "completed_streams"
	err = en.Append(0xb1, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedStreams)
	if err != nil {
		err = msgp.WrapError(err, "CompletedStreams")
		return
	}
	// write "part_number"
	err = en.Append(0xab, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PartNumber)
	if err != nil {
		err = msgp.WrapError(err, "PartNumber")
		return
	}
	// write "total_parts"
	err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.TotalParts)
	if err != nil {
		err = msgp.WrapError(err, "TotalParts")
		return
	}
	// write "guid"
	err = en.Append(0xa4, 0x67, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Guid)
	if err != nil {
		err = msgp.WrapError(err, "Guid")
		return
	}
	// write "current_file_count"
	err = en.Append(0xb2, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CurrentFileCount)
	if err != nil {
		err = msgp.WrapError(err, "CurrentFileCount")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressExtract) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "image"
	o = append(o, 0x8d, 0xa5, 0x69, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendUint32(o, z.Image)
	// string "extract_flags"
	o = append(o, 0xad, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, z.ExtractFlags)
	// string "wimfile_name"
	o = append(o, 0xac, 0x77, 0x69, 0x6d, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.WimfileName)
	// string "image_name"
	o = append(o, 0xaa, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ImageName)
	// string "target"
	o = append(o, 0xa6, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74)
	o = msgp.AppendString(o, z.Target)
	// string "total_bytes"
	o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.TotalBytes)
	// string "completed_bytes"
	o = append(o, 0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.CompletedBytes)
	// string "total_streams"
	o = append(o, 0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	o = msgp.AppendUint64(o, z.TotalStreams)
	// string "completed_streams"
	o = append(o, 0xb1, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	o = msgp.AppendUint64(o, z.CompletedStreams)
	// string "part_number"
	o = append(o, 0xab, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendUint32(o, z.PartNumber)
	// string "total_parts"
	o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendUint32(o, z.TotalParts)
	// string "guid"
	o = append(o, 0xa4, 0x67, 0x75, 0x69, 0x64)
	o = msgp.AppendBytes(o, z.Guid)
	// string "current_file_count"
	o = append(o, 0xb2, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.CurrentFileCount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressExtract) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "image":
			z.Image, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Image")
				return
			}
		case "extract_flags":
			z.ExtractFlags, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExtractFlags")
				return
			}
		case "wimfile_name":
			z.WimfileName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WimfileName")
				return
			}
		case "image_name":
			z.ImageName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImageName")
				return
			}
		case "target":
			z.Target, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Target")
				return
			}
		case "total_bytes":
			z.TotalBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "total_streams":
			z.TotalStreams, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalStreams")
				return
			}
		case "completed_streams":
			z.CompletedStreams, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedStreams")
				return
			}
		case "part_number":
			z.PartNumber, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PartNumber")
				return
			}
		case "total_parts":
			z.TotalParts, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalParts")
				return
			}
		case "guid":
			z.Guid, bts, err = msgp.ReadBytesBytes(bts, z.Guid)
			if err != nil {
				err = msgp.WrapError(err, "Guid")
				return
			}
		case "current_file_count":
			z.CurrentFileCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentFileCount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressExtract) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint32Size + 14 + msgp.Uint32Size + 13 + msgp.StringPrefixSize + len(z.WimfileName) + 11 + msgp.StringPrefixSize + len(z.ImageName) + 7 + msgp.StringPrefixSize + len(z.Target) + 12 + msgp.Uint64Size + 16 + msgp.Uint64Size + 14 + msgp.Uint64Size + 18 + msgp.Uint64Size + 12 + msgp.Uint32Size + 12 + msgp.Uint32Size + 5 + msgp.BytesPrefixSize + len(z.Guid) + 19 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressHandleError) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "error_code":
			z.ErrorCode, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ErrorCode")
				return
			}
		case "will_ignore":
			z.WillIgnore, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "WillIgnore")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressHandleError) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "path"
	err = en.Append(0x83, 0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "error_code"
	err = en.Append(0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ErrorCode)
	if err != nil {
		err = msgp.WrapError(err, "ErrorCode")
		return
	}
	// write "will_ignore"
	err = en.Append(0xab, 0x77, 0x69, 0x6c, 0x6c, 0x5f, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.WillIgnore)
	if err != nil {
		err = msgp.WrapError(err, "WillIgnore")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressHandleError) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "path"
	o = append(o, 0x83, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "error_code"
	o = append(o, 0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.ErrorCode)
	// string "will_ignore"
	o = append(o, 0xab, 0x77, 0x69, 0x6c, 0x6c, 0x5f, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65)
	o = msgp.AppendBool(o, z.WillIgnore)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressHandleError) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "error_code":
			z.ErrorCode, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ErrorCode")
				return
			}
		case "will_ignore":
			z.WillIgnore, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WillIgnore")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressHandleError) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Path) + 11 + msgp.IntSize + 12 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressIntegrity) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_bytes":
			z.TotalBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "total_chunks":
			z.TotalChunks, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "TotalChunks")
				return
			}
		case "completed_chunks":
			z.CompletedChunks, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "CompletedChunks")
				return
			}
		case "chunk_size":
			z.ChunkSize, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "ChunkSize")
				return
			}
		case "filename":
			z.Filename, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Filename")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressIntegrity) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "total_bytes"
	err = en.Append(0x86, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalBytes)
	if err != nil {
		err = msgp.WrapError(err, "TotalBytes")
		return
	}
	// write "completed_bytes"
	err = en.Append(0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedBytes)
	if err != nil {
		err = msgp.WrapError(err, "CompletedBytes")
		return
	}
	// write "total_chunks"
	err = en.Append(0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.TotalChunks)
	if err != nil {
		err = msgp.WrapError(err, "TotalChunks")
		return
	}
	// write "completed_chunks"
	err = en.Append(0xb0, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.CompletedChunks)
	if err != nil {
		err = msgp.WrapError(err, "CompletedChunks")
		return
	}
	// write "chunk_size"
	err = en.Append(0xaa, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.ChunkSize)
	if err != nil {
		err = msgp.WrapError(err, "ChunkSize")
		return
	}
	// write "filename"
	err = en.Append(0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Filename)
	if err != nil {
		err = msgp.WrapError(err, "Filename")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressIntegrity) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "total_bytes"
	o = append(o, 0x86, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.TotalBytes)
	// string "completed_bytes"
	o = append(o, 0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.CompletedBytes)
	// string "total_chunks"
	o = append(o, 0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73)
	o = msgp.AppendUint32(o, z.TotalChunks)
	// string "completed_chunks"
	o = append(o, 0xb0, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73)
	o = msgp.AppendUint32(o, z.CompletedChunks)
	// string "chunk_size"
	o = append(o, 0xaa, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint32(o, z.ChunkSize)
	// string "filename"
	o = append(o, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Filename)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressIntegrity) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_bytes":
			z.TotalBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "total_chunks":
			z.TotalChunks, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalChunks")
				return
			}
		case "completed_chunks":
			z.CompletedChunks, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedChunks")
				return
			}
		case "chunk_size":
			z.ChunkSize, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChunkSize")
				return
			}
		case "filename":
			z.Filename, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Filename")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressIntegrity) Msgsize() (s int) {
	s = 1 + 12 + msgp.Uint64Size + 16 + msgp.Uint64Size + 13 + msgp.Uint32Size + 17 + msgp.Uint32Size + 11 + msgp.Uint32Size + 9 + msgp.StringPrefixSize + len(z.Filename)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "msg_type":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MsgType")
					return
				}
				z.MsgType = ProgressMsgType(zb0002)
			}
		case "info":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
			if z.Info == nil {
				z.Info = make(map[string]interface{}, zb0003)
			} else if len(z.Info) > 0 {
				for key := range z.Info {
					delete(z.Info, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Info")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Info", za0001)
					return
				}
				z.Info[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "msg_type"
	err = en.Append(0x82, 0xa8, 0x6d, 0x73, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.MsgType))
	if err != nil {
		err = msgp.WrapError(err, "MsgType")
		return
	}
	// write "info"
	err = en.Append(0xa4, 0x69, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Info)))
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	for za0001, za0002 := range z.Info {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Info")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Info", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "msg_type"
	o = append(o, 0x82, 0xa8, 0x6d, 0x73, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, int(z.MsgType))
	// string "info"
	o = append(o, 0xa4, 0x69, 0x6e, 0x66, 0x6f)
	o = msgp.AppendMapHeader(o, uint32(len(z.Info)))
	for za0001, za0002 := range z.Info {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "Info", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "msg_type":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MsgType")
					return
				}
				z.MsgType = ProgressMsgType(zb0002)
			}
		case "info":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
			if z.Info == nil {
				z.Info = make(map[string]interface{}, zb0003)
			} else if len(z.Info) > 0 {
				for key := range z.Info {
					delete(z.Info, key)
				}
			}
			for zb0003 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0003--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Info")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Info", za0001)
					return
				}
				z.Info[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressMsg) Msgsize() (s int) {
	s = 1 + 9 + msgp.IntSize + 5 + msgp.MapHeaderSize
	if z.Info != nil {
		for za0001, za0002 := range z.Info {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressMsgType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ProgressMsgType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressMsgType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressMsgType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressMsgType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ProgressMsgType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressMsgType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressRename) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "from":
			z.From, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		case "to":
			z.To, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "To")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressRename) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "from"
	err = en.Append(0x82, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.From)
	if err != nil {
		err = msgp.WrapError(err, "From")
		return
	}
	// write "to"
	err = en.Append(0xa2, 0x74, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.To)
	if err != nil {
		err = msgp.WrapError(err, "To")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressRename) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "from"
	o = append(o, 0x82, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
	o = msgp.AppendString(o, z.From)
	// string "to"
	o = append(o, 0xa2, 0x74, 0x6f)
	o = msgp.AppendString(o, z.To)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressRename) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "from":
			z.From, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		case "to":
			z.To, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "To")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressRename) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.From) + 3 + msgp.StringPrefixSize + len(z.To)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressReplaceFileInWim) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path_in_wim":
			z.PathInWim, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathInWim")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressReplaceFileInWim) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "path_in_wim"
	err = en.Append(0x81, 0xab, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x69, 0x6e, 0x5f, 0x77, 0x69, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathInWim)
	if err != nil {
		err = msgp.WrapError(err, "PathInWim")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressReplaceFileInWim) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "path_in_wim"
	o = append(o, 0x81, 0xab, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x69, 0x6e, 0x5f, 0x77, 0x69, 0x6d)
	o = msgp.AppendString(o, z.PathInWim)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressReplaceFileInWim) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path_in_wim":
			z.PathInWim, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathInWim")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressReplaceFileInWim) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.PathInWim)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressScan) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "source":
			z.Source, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "cur_path":
			z.CurPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CurPath")
				return
			}
		case "status":
			z.Status, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "wim_target_path":
			z.WimTargetPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WimTargetPath")
				return
			}
		case "num_dirs_scanned":
			z.NumDirsScanned, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "NumDirsScanned")
				return
			}
		case "num_nondirs_scanned":
			z.NumNondirsScanned, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "NumNondirsScanned")
				return
			}
		case "num_bytes_scanned":
			z.NumBytesScanned, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "NumBytesScanned")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressScan) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "source"
	err = en.Append(0x87, 0xa6, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Source)
	if err != nil {
		err = msgp.WrapError(err, "Source")
		return
	}
	// write "cur_path"
	err = en.Append(0xa8, 0x63, 0x75, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.CurPath)
	if err != nil {
		err = msgp.WrapError(err, "CurPath")
		return
	}
	// write "status"
	err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Status)
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	// write "wim_target_path"
	err = en.Append(0xaf, 0x77, 0x69, 0x6d, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.WimTargetPath)
	if err != nil {
		err = msgp.WrapError(err, "WimTargetPath")
		return
	}
	// write "num_dirs_scanned"
	err = en.Append(0xb0, 0x6e, 0x75, 0x6d, 0x5f, 0x64, 0x69, 0x72, 0x73, 0x5f, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.NumDirsScanned)
	if err != nil {
		err = msgp.WrapError(err, "NumDirsScanned")
		return
	}
	// write "num_nondirs_scanned"
	err = en.Append(0xb3, 0x6e, 0x75, 0x6d, 0x5f, 0x6e, 0x6f, 0x6e, 0x64, 0x69, 0x72, 0x73, 0x5f, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.NumNondirsScanned)
	if err != nil {
		err = msgp.WrapError(err, "NumNondirsScanned")
		return
	}
	// write "num_bytes_scanned"
	err = en.Append(0xb1, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.NumBytesScanned)
	if err != nil {
		err = msgp.WrapError(err, "NumBytesScanned")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressScan) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "source"
	o = append(o, 0x87, 0xa6, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65)
	o = msgp.AppendString(o, z.Source)
	// string "cur_path"
	o = append(o, 0xa8, 0x63, 0x75, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.CurPath)
	// string "status"
	o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendInt(o, z.Status)
	// string "wim_target_path"
	o = append(o, 0xaf, 0x77, 0x69, 0x6d, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.WimTargetPath)
	// string "num_dirs_scanned"
	o = append(o, 0xb0, 0x6e, 0x75, 0x6d, 0x5f, 0x64, 0x69, 0x72, 0x73, 0x5f, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.NumDirsScanned)
	// string "num_nondirs_scanned"
	o = append(o, 0xb3, 0x6e, 0x75, 0x6d, 0x5f, 0x6e, 0x6f, 0x6e, 0x64, 0x69, 0x72, 0x73, 0x5f, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.NumNondirsScanned)
	// string "num_bytes_scanned"
	o = append(o, 0xb1, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.NumBytesScanned)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressScan) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "source":
			z.Source, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "cur_path":
			z.CurPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurPath")
				return
			}
		case "status":
			z.Status, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "wim_target_path":
			z.WimTargetPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WimTargetPath")
				return
			}
		case "num_dirs_scanned":
			z.NumDirsScanned, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumDirsScanned")
				return
			}
		case "num_nondirs_scanned":
			z.NumNondirsScanned, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumNondirsScanned")
				return
			}
		case "num_bytes_scanned":
			z.NumBytesScanned, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumBytesScanned")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressScan) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Source) + 9 + msgp.StringPrefixSize + len(z.CurPath) + 7 + msgp.IntSize + 16 + msgp.StringPrefixSize + len(z.WimTargetPath) + 17 + msgp.Uint64Size + 20 + msgp.Uint64Size + 18 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressSplit) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_bytes":
			z.TotalBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "cur_part_number":
			z.CurPartNumber, err = dc.ReadUint()
			if err != nil {
				err = msgp.WrapError(err, "CurPartNumber")
				return
			}
		case "total_parts":
			z.TotalParts, err = dc.ReadUint()
			if err != nil {
				err = msgp.WrapError(err, "TotalParts")
				return
			}
		case "part_name":
			z.PartName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PartName")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressSplit) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "total_bytes"
	err = en.Append(0x85, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalBytes)
	if err != nil {
		err = msgp.WrapError(err, "TotalBytes")
		return
	}
	// write "completed_bytes"
	err = en.Append(0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedBytes)
	if err != nil {
		err = msgp.WrapError(err, "CompletedBytes")
		return
	}
	// write "cur_part_number"
	err = en.Append(0xaf, 0x63, 0x75, 0x72, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint(z.CurPartNumber)
	if err != nil {
		err = msgp.WrapError(err, "CurPartNumber")
		return
	}
	// write "total_parts"
	err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint(z.TotalParts)
	if err != nil {
		err = msgp.WrapError(err, "TotalParts")
		return
	}
	// write "part_name"
	err = en.Append(0xa9, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.PartName)
	if err != nil {
		err = msgp.WrapError(err, "PartName")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressSplit) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "total_bytes"
	o = append(o, 0x85, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.TotalBytes)
	// string "completed_bytes"
	o = append(o, 0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.CompletedBytes)
	// string "cur_part_number"
	o = append(o, 0xaf, 0x63, 0x75, 0x72, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendUint(o, z.CurPartNumber)
	// string "total_parts"
	o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendUint(o, z.TotalParts)
	// string "part_name"
	o = append(o, 0xa9, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.PartName)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressSplit) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_bytes":
			z.TotalBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "cur_part_number":
			z.CurPartNumber, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurPartNumber")
				return
			}
		case "total_parts":
			z.TotalParts, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalParts")
				return
			}
		case "part_name":
			z.PartName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PartName")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressSplit) Msgsize() (s int) {
	s = 1 + 12 + msgp.Uint64Size + 16 + msgp.Uint64Size + 16 + msgp.UintSize + 12 + msgp.UintSize + 10 + msgp.StringPrefixSize + len(z.PartName)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressTestFileExclusion) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "will_exclude":
			z.WillExclude, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "WillExclude")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressTestFileExclusion) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "path"
	err = en.Append(0x82, 0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "will_exclude"
	err = en.Append(0xac, 0x77, 0x69, 0x6c, 0x6c, 0x5f, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.WillExclude)
	if err != nil {
		err = msgp.WrapError(err, "WillExclude")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressTestFileExclusion) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "path"
	o = append(o, 0x82, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "will_exclude"
	o = append(o, 0xac, 0x77, 0x69, 0x6c, 0x6c, 0x5f, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65)
	o = msgp.AppendBool(o, z.WillExclude)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressTestFileExclusion) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "will_exclude":
			z.WillExclude, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WillExclude")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressTestFileExclusion) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Path) + 13 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressUnmount) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mountpoint":
			z.Mountpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Mountpoint")
				return
			}
		case "mounted_wim":
			z.MountedWim, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MountedWim")
				return
			}
		case "mounted_image":
			z.MountedImage, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "MountedImage")
				return
			}
		case "mount_flags":
			z.MountFlags, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "MountFlags")
				return
			}
		case "unmount_flags":
			z.UnmountFlags, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "UnmountFlags")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressUnmount) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "mountpoint"
	err = en.Append(0x85, 0xaa, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Mountpoint)
	if err != nil {
		err = msgp.WrapError(err, "Mountpoint")
		return
	}
	// write "mounted_wim"
	err = en.Append(0xab, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x5f, 0x77, 0x69, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.MountedWim)
	if err != nil {
		err = msgp.WrapError(err, "MountedWim")
		return
	}
	// write "mounted_image"
	err = en.Append(0xad, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.MountedImage)
	if err != nil {
		err = msgp.WrapError(err, "MountedImage")
		return
	}
	// write "mount_flags"
	err = en.Append(0xab, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.MountFlags)
	if err != nil {
		err = msgp.WrapError(err, "MountFlags")
		return
	}
	// write "unmount_flags"
	err = en.Append(0xad, 0x75, 0x6e, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.UnmountFlags)
	if err != nil {
		err = msgp.WrapError(err, "UnmountFlags")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressUnmount) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "mountpoint"
	o = append(o, 0x85, 0xaa, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Mountpoint)
	// string "mounted_wim"
	o = append(o, 0xab, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x5f, 0x77, 0x69, 0x6d)
	o = msgp.AppendString(o, z.MountedWim)
	// string "mounted_image"
	o = append(o, 0xad, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendUint32(o, z.MountedImage)
	// string "mount_flags"
	o = append(o, 0xab, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, z.MountFlags)
	// string "unmount_flags"
	o = append(o, 0xad, 0x75, 0x6e, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, z.UnmountFlags)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressUnmount) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mountpoint":
			z.Mountpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mountpoint")
				return
			}
		case "mounted_wim":
			z.MountedWim, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MountedWim")
				return
			}
		case "mounted_image":
			z.MountedImage, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MountedImage")
				return
			}
		case "mount_flags":
			z.MountFlags, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MountFlags")
				return
			}
		case "unmount_flags":
			z.UnmountFlags, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UnmountFlags")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressUnmount) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Mountpoint) + 12 + msgp.StringPrefixSize + len(z.MountedWim) + 14 + msgp.Uint32Size + 12 + msgp.Uint32Size + 14 + msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressUpdate) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "command":
			z.Command, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Command")
				return
			}
		case "completed_commands":
			z.CompletedCommands, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedCommands")
				return
			}
		case "total_commands":
			z.TotalCommands, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalCommands")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressUpdate) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "command"
	err = en.Append(0x83, 0xa7, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Command)
	if err != nil {
		err = msgp.WrapError(err, "Command")
		return
	}
	// write "completed_commands"
	err = en.Append(0xb2, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedCommands)
	if err != nil {
		err = msgp.WrapError(err, "CompletedCommands")
		return
	}
	// write "total_commands"
	err = en.Append(0xae, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalCommands)
	if err != nil {
		err = msgp.WrapError(err, "TotalCommands")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "command"
	o = append(o, 0x83, 0xa7, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64)
	o = msgp.AppendUint64(o, z.Command)
	// string "completed_commands"
	o = append(o, 0xb2, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73)
	o = msgp.AppendUint64(o, z.CompletedCommands)
	// string "total_commands"
	o = append(o, 0xae, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73)
	o = msgp.AppendUint64(o, z.TotalCommands)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "command":
			z.Command, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Command")
				return
			}
		case "completed_commands":
			z.CompletedCommands, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedCommands")
				return
			}
		case "total_commands":
			z.TotalCommands, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalCommands")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressUpdate) Msgsize() (s int) {
	s = 1 + 8 + msgp.Uint64Size + 19 + msgp.Uint64Size + 15 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressVerifyImage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "wimfile":
			z.Wimfile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Wimfile")
				return
			}
		case "total_images":
			z.TotalImages, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "TotalImages")
				return
			}
		case "current_image":
			z.CurrentImage, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "CurrentImage")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressVerifyImage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "wimfile"
	err = en.Append(0x83, 0xa7, 0x77, 0x69, 0x6d, 0x66, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Wimfile)
	if err != nil {
		err = msgp.WrapError(err, "Wimfile")
		return
	}
	// write "total_images"
	err = en.Append(0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.TotalImages)
	if err != nil {
		err = msgp.WrapError(err, "TotalImages")
		return
	}
	// write "current_image"
	err = en.Append(0xad, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.CurrentImage)
	if err != nil {
		err = msgp.WrapError(err, "CurrentImage")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressVerifyImage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "wimfile"
	o = append(o, 0x83, 0xa7, 0x77, 0x69, 0x6d, 0x66, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Wimfile)
	// string "total_images"
	o = append(o, 0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73)
	o = msgp.AppendUint32(o, z.TotalImages)
	// string "current_image"
	o = append(o, 0xad, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendUint32(o, z.CurrentImage)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressVerifyImage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "wimfile":
			z.Wimfile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Wimfile")
				return
			}
		case "total_images":
			z.TotalImages, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalImages")
				return
			}
		case "current_image":
			z.CurrentImage, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentImage")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressVerifyImage) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Wimfile) + 13 + msgp.Uint32Size + 14 + msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressVerifyStreams) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "wimfile":
			z.Wimfile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Wimfile")
				return
			}
		case "total_streams":
			z.TotalStreams, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalStreams")
				return
			}
		case "total_bytes":
			z.TotalBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_streams":
			z.CompletedStreams, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedStreams")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressVerifyStreams) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "wimfile"
	err = en.Append(0x85, 0xa7, 0x77, 0x69, 0x6d, 0x66, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Wimfile)
	if err != nil {
		err = msgp.WrapError(err, "Wimfile")
		return
	}
	// write "total_streams"
	err = en.Append(0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalStreams)
	if err != nil {
		err = msgp.WrapError(err, "TotalStreams")
		return
	}
	// write "total_bytes"
	err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalBytes)
	if err != nil {
		err = msgp.WrapError(err, "TotalBytes")
		return
	}
	// write "completed_streams"
	err = en.Append(0xb1, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedStreams)
	if err != nil {
		err = msgp.WrapError(err, "CompletedStreams")
		return
	}
	// write "completed_bytes"
	err = en.Append(0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedBytes)
	if err != nil {
		err = msgp.WrapError(err, "CompletedBytes")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressVerifyStreams) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "wimfile"
	o = append(o, 0x85, 0xa7, 0x77, 0x69, 0x6d, 0x66, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Wimfile)
	// string "total_streams"
	o = append(o, 0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	o = msgp.AppendUint64(o, z.TotalStreams)
	// string "total_bytes"
	o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.TotalBytes)
	// string "completed_streams"
	o = append(o, 0xb1, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	o = msgp.AppendUint64(o, z.CompletedStreams)
	// string "completed_bytes"
	o = append(o, 0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.CompletedBytes)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressVerifyStreams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "wimfile":
			z.Wimfile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Wimfile")
				return
			}
		case "total_streams":
			z.TotalStreams, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalStreams")
				return
			}
		case "total_bytes":
			z.TotalBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "completed_streams":
			z.CompletedStreams, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedStreams")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressVerifyStreams) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Wimfile) + 14 + msgp.Uint64Size + 12 + msgp.Uint64Size + 18 + msgp.Uint64Size + 16 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressWimbootExclude) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path_in_wim":
			z.PathInWim, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathInWim")
				return
			}
		case "extraction_path":
			z.ExtractionPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ExtractionPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProgressWimbootExclude) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "path_in_wim"
	err = en.Append(0x82, 0xab, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x69, 0x6e, 0x5f, 0x77, 0x69, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathInWim)
	if err != nil {
		err = msgp.WrapError(err, "PathInWim")
		return
	}
	// write "extraction_path"
	err = en.Append(0xaf, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.ExtractionPath)
	if err != nil {
		err = msgp.WrapError(err, "ExtractionPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProgressWimbootExclude) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "path_in_wim"
	o = append(o, 0x82, 0xab, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x69, 0x6e, 0x5f, 0x77, 0x69, 0x6d)
	o = msgp.AppendString(o, z.PathInWim)
	// string "extraction_path"
	o = append(o, 0xaf, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.ExtractionPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressWimbootExclude) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "path_in_wim":
			z.PathInWim, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathInWim")
				return
			}
		case "extraction_path":
			z.ExtractionPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExtractionPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProgressWimbootExclude) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.PathInWim) + 16 + msgp.StringPrefixSize + len(z.ExtractionPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProgressWriteStreams) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_bytes":
			z.TotalBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "total_streams":
			z.TotalStreams, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalStreams")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "completed_streams":
			z.CompletedStreams, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedStreams")
				return
			}
		case "num_threads":
			z.NumThreads, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "NumThreads")
				return
			}
		case "compression_type":
			z.CompressionType, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "CompressionType")
				return
			}
		case "total_parts":
			z.TotalParts, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "TotalParts")
				return
			}
		case "completed_parts":
			z.CompletedParts, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "CompletedParts")
				return
			}
		case "completed_compressed_bytes":
			z.CompletedCompressedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CompletedCompressedBytes")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProgressWriteStreams) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "total_bytes"
	err = en.Append(0x89, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalBytes)
	if err != nil {
		err = msgp.WrapError(err, "TotalBytes")
		return
	}
	// write "total_streams"
	err = en.Append(0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalStreams)
	if err != nil {
		err = msgp.WrapError(err, "TotalStreams")
		return
	}
	// write "completed_bytes"
	err = en.Append(0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedBytes)
	if err != nil {
		err = msgp.WrapError(err, "CompletedBytes")
		return
	}
	// write "completed_streams"
	err = en.Append(0xb1, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedStreams)
	if err != nil {
		err = msgp.WrapError(err, "CompletedStreams")
		return
	}
	// write "num_threads"
	err = en.Append(0xab, 0x6e, 0x75, 0x6d, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.NumThreads)
	if err != nil {
		err = msgp.WrapError(err, "NumThreads")
		return
	}
	// write "compression_type"
	err = en.Append(0xb0, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.CompressionType)
	if err != nil {
		err = msgp.WrapError(err, "CompressionType")
		return
	}
	// write "total_parts"
	err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.TotalParts)
	if err != nil {
		err = msgp.WrapError(err, "TotalParts")
		return
	}
	// write "completed_parts"
	err = en.Append(0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.CompletedParts)
	if err != nil {
		err = msgp.WrapError(err, "CompletedParts")
		return
	}
	// write "completed_compressed_bytes"
	err = en.Append(0xba, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CompletedCompressedBytes)
	if err != nil {
		err = msgp.WrapError(err, "CompletedCompressedBytes")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProgressWriteStreams) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "total_bytes"
	o = append(o, 0x89, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.TotalBytes)
	// string "total_streams"
	o = append(o, 0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	o = msgp.AppendUint64(o, z.TotalStreams)
	// string "completed_bytes"
	o = append(o, 0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.CompletedBytes)
	// string "completed_streams"
	o = append(o, 0xb1, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
	o = msgp.AppendUint64(o, z.CompletedStreams)
	// string "num_threads"
	o = append(o, 0xab, 0x6e, 0x75, 0x6d, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73)
	o = msgp.AppendUint32(o, z.NumThreads)
	// string "compression_type"
	o = append(o, 0xb0, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendInt32(o, z.CompressionType)
	// string "total_parts"
	o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendUint32(o, z.TotalParts)
	// string "completed_parts"
	o = append(o, 0xaf, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendUint32(o, z.CompletedParts)
	// string "completed_compressed_bytes"
	o = append(o, 0xba, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.CompletedCompressedBytes)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProgressWriteStreams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_bytes":
			z.TotalBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalBytes")
				return
			}
		case "total_streams":
			z.TotalStreams, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalStreams")
				return
			}
		case "completed_bytes":
			z.CompletedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedBytes")
				return
			}
		case "completed_streams":
			z.CompletedStreams, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedStreams")
				return
			}
		case "num_threads":
			z.NumThreads, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumThreads")
				return
			}
		case "compression_type":
			z.CompressionType, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompressionType")
				return
			}
		case "total_parts":
			z.TotalParts, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalParts")
				return
			}
		case "completed_parts":
			z.CompletedParts, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedParts")
				return
			}
		case "completed_compressed_bytes":
			z.CompletedCompressedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompletedCompressedBytes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProgressWriteStreams) Msgsize() (s int) {
	s = 1 + 12 + msgp.Uint64Size + 14 + msgp.Uint64Size + 16 + msgp.Uint64Size + 18 + msgp.Uint64Size + 12 + msgp.Uint32Size + 17 + msgp.Int32Size + 12 + msgp.Uint32Size + 16 + msgp.Uint32Size + 27 + msgp.Uint64Size
	return
}
